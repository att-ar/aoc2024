module Day02.Day02 (doDay02) where

import qualified Data.ByteString.Char8 as BS8
import Data.Maybe (mapMaybe)
import Lib (readIntBS8)

-- Parses a line into [Int]
parseLineIntoReport :: BS8.ByteString -> [Int]
parseLineIntoReport = mapMaybe readIntBS8 . BS8.words

-- f(x, y) = x < y
isLessThan :: Int -> Int -> Bool
isLessThan x y = x < y

-- f(x, y) = x > y
isGreaterThan :: Int -> Int -> Bool
isGreaterThan x y = x > y

-- f(x, y) = |x - y| <= 3 and x != y
isClose :: Int -> Int -> Bool
isClose x y = abs (x - y) <= 3

isPerfectReport :: (Int -> Int -> Bool) -> [Int] -> Bool
isPerfectReport _ [] = True
isPerfectReport _ [_] = True
isPerfectReport checkOrder (first : second : reports) = checkOrder first second && isClose first second && isPerfectReport checkOrder (second : reports)

{-
Check
  - if you can get a strictly increasing and close array
  - if you can get a strictly decreasing and close array
-}
isValidReport :: [Int] -> Bool
isValidReport reports =
  isPerfectReport isLessThan reports || isPerfectReport isGreaterThan reports

{-
  Gemini said folding is less idiomatic and less efficient here:
    idk if i believe it though because it shouldn't have to keep the entire array in memory at once
  let sumValidReports :: Int -> [Int] -> Int
      sumValidReports acc lvls = acc + isValidReport lvls
  print (foldl' sumValidReports 0 (map parseLineIntoReport (BS8.lines contents)))
-}
day02P1 :: FilePath -> IO ()
day02P1 filepath = do
  contents <- BS8.readFile filepath
  -- convert each line in (BS8.line contents) from BS8.ByteString to [Int] by applying parseLineIntoReport
  -- Then apply isValidReport which just returns Bool for each report
  -- Then convert to Int using fromEnum
  -- Then sum
  print (sum (map (fromEnum . isValidReport . parseLineIntoReport) (BS8.lines contents)))

-- All subarrays formed by removing one element
makeSubarrays :: [Int] -> [[Int]]
makeSubarrays [] = []
makeSubarrays xs = [take i xs ++ drop (i + 1) xs | i <- [0 .. length xs - 1]]

{-
  Just run isValidReport on every subarray formed by excluding one element until a valid one is found
-}
isFlexibleValidReport :: [Int] -> Bool
isFlexibleValidReport [] = True
isFlexibleValidReport [_] = True -- 1 element can never be invalid
isFlexibleValidReport reports = any isValidReport (makeSubarrays reports)

{-
  Report is also valid if removing one level makes the report valid
  Removed the do just to show that you can single line using the =<< Bind (reverse direction of >>=)
  It extracts the value generated by the readFile IO action
-}
day02P2 :: FilePath -> IO ()
day02P2 filepath = print . sum . map (fromEnum . isFlexibleValidReport . parseLineIntoReport) . BS8.lines =<< BS8.readFile filepath

{- Function to run Day 2 -}
doDay02 :: IO ()
doDay02 = do
  print "--- Day 02 ---"

  print " -- Part 1"
  day02P1 "src/Day02/day02_small.txt"
  day02P1 "src/Day02/day02.txt"

  print " -- Part 2"
  day02P2 "src/Day02/day02_small.txt"
  day02P2 "src/Day02/day02.txt"
